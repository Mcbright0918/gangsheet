// Ensure React and react-konva compatibility
// Required versions in package.json:
// "react": "18.2.0",
// "react-dom": "18.2.0",
// "react-konva": "18.2.3"

import React, { useRef, useState, useEffect } from 'react';
import { Stage, Layer, Text as KonvaText, Transformer, Image as KonvaImage } from 'react-konva';
import useImage from 'use-image';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

const inchToPx = 300; // 1 inch = 300px

const canvasPresets = {
  '22x39': { width: 22 * inchToPx, height: 39 * inchToPx },
  '22x18': { width: 22 * inchToPx, height: 18 * inchToPx },
};

const URLImage = ({ image, isSelected, onSelect, onChange }) => {
  const shapeRef = useRef();
  const trRef = useRef();
  const [img] = useImage(image.src);

  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current]);
      trRef.current.getLayer().batchDraw();
    }
  }, [isSelected]);

  return (
    <>
      <KonvaImage
        image={img}
        x={image.x}
        y={image.y}
        width={image.width}
        height={image.height}
        rotation={image.rotation}
        draggable
        ref={shapeRef}
        onClick={onSelect}
        onTap={onSelect}
        onDragEnd={(e) => {
          onChange({ ...image, x: e.target.x(), y: e.target.y() });
        }}
        onTransformEnd={(e) => {
          const node = shapeRef.current;
          const scaleX = node.scaleX();
          const scaleY = node.scaleY();

          // reset scale
          node.scaleX(1);
          node.scaleY(1);

          onChange({
            ...image,
            x: node.x(),
            y: node.y(),
            rotation: node.rotation(),
            width: Math.max(5, node.width() * scaleX),
            height: Math.max(5, node.height() * scaleY),
          });
        }}
      />
      {isSelected && <Transformer ref={trRef} rotateEnabled={true} enabledAnchors={["top-left", "top-right", "bottom-left", "bottom-right"]} />}
    </>
  );
};

export default function DtfEditor() {
  const [canvasSize, setCanvasSize] = useState(canvasPresets['22x39']);
  const [images, setImages] = useState([]);
  const [texts, setTexts] = useState([]);
  const [selectedId, setSelectedId] = useState(null);
  const stageRef = useRef();

  const handleExportPDF = async () => {
    const uri = stageRef.current.toDataURL();
    const pdf = new jsPDF({ unit: 'px', format: [canvasSize.width, canvasSize.height] });
    pdf.addImage(uri, 'PNG', 0, 0);
    pdf.save('gangsheet.pdf');
  };

  const handleExportPNG = () => {
    const uri = stageRef.current.toDataURL();
    const link = document.createElement('a');
    link.download = 'gangsheet.png';
    link.href = uri;
    link.click();
  };

  const addText = () => {
    const newText = {
      id: Date.now().toString(),
      type: 'text',
      text: 'Sample Text',
      x: 50,
      y: 50,
      fontSize: 32,
      draggable: true,
    };
    setTexts([...texts, newText]);
  };

  const updateText = (id, attrs) => {
    const updated = texts.map((el) => (el.id === id ? { ...el, ...attrs } : el));
    setTexts(updated);
  };

  const handleFileChange = (e) => {
    const files = e.target.files;
    Array.from(files).forEach((file) => {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new window.Image();
        img.onload = () => {
          const newImage = {
            id: Date.now().toString(),
            src: reader.result,
            x: 50,
            y: 50,
            width: img.width,
            height: img.height,
            rotation: 0,
          };
          setImages((prev) => [...prev, newImage]);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    });
  };

  return (
    <div style={{ padding: 10 }}>
      <div style={{ marginBottom: 10 }}>
        <button onClick={() => setCanvasSize(canvasPresets['22x39'])}>22x39"</button>
        <button onClick={() => setCanvasSize(canvasPresets['22x18'])}>22x18"</button>
        <input type="file" multiple accept="image/*" onChange={handleFileChange} />
        <button onClick={addText}>Add Text</button>
        <button onClick={handleExportPNG}>Export PNG</button>
        <button onClick={handleExportPDF}>Export PDF</button>
      </div>

      <div
        style={{
          width: '100%',
          height: '80vh',
          overflow: 'auto',
          border: '1px solid #ccc',
          background: '#f9f9f9',
        }}
      >
        <Stage
          width={canvasSize.width}
          height={canvasSize.height}
          ref={stageRef}
          style={{ background: '#fff', margin: '0 auto', display: 'block' }}
          onMouseDown={(e) => {
            const clickedOnEmpty = e.target === e.target.getStage();
            if (clickedOnEmpty) setSelectedId(null);
          }}
        >
          <Layer>
            {images.map((img, i) => (
              <URLImage
                key={img.id}
                image={img}
                isSelected={img.id === selectedId}
                onSelect={() => setSelectedId(img.id)}
                onChange={(newAttrs) => {
                  const imgs = images.slice();
                  imgs[i] = newAttrs;
                  setImages(imgs);
                }}
              />
            ))}
            {texts.map((el, i) => (
              <KonvaText
                key={el.id}
                {...el}
                onClick={() => setSelectedId(el.id)}
                onTap={() => setSelectedId(el.id)}
                onDragEnd={(e) => {
                  updateText(el.id, {
                    x: e.target.x(),
                    y: e.target.y(),
                  });
                }}
              />
            ))}
            <Transformer
              nodes={
                selectedId
                  ? [
                      ...images.filter((el) => el.id === selectedId).map(() => stageRef.current.findOne(`#${selectedId}`)),
                      ...texts.filter((el) => el.id === selectedId).map(() => stageRef.current.findOne(`#${selectedId}`))
                    ].filter(Boolean)
                  : []
              }
              boundBoxFunc={(oldBox, newBox) => newBox}
            />
          </Layer>
        </Stage>
      </div>
    </div>
  );
}
